var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AbstractAdapter = function () {

  /**
   * Adapter constructor
   */
  function AbstractAdapter() {
    _classCallCheck(this, AbstractAdapter);

    if (new.target === AbstractAdapter) {
      throw new TypeError('Cannot construct Adapter instance directly.');
    }
  }

  /**
   * Get current keyPrefix.
   *
   * @return {string}
   */


  _createClass(AbstractAdapter, [{
    key: 'getDriver',
    value: function getDriver() {}

    /**
     * Set current driver.
     *
     * @param {object|function}
     */

  }, {
    key: 'setDriver',
    value: function setDriver(value) {}

    /**
     * Get current keyPrefix.
     *
     * @return {string}
     */

  }, {
    key: 'getKeyPrefix',
    value: function getKeyPrefix() {}

    /**
     * Set current keyPrefix.
     *
     * @param {string}
     */

  }, {
    key: 'setKeyPrefix',
    value: function setKeyPrefix(value) {}

    /**
     * Get current serializer.
     *
     * @returns {AbstractSerializer}
     */

  }, {
    key: 'getSerializer',
    value: function getSerializer() {}

    /**
     * Set current serializer.
     *
     * @param {AbstractSerializer}   givenSerializer
     */

  }, {
    key: 'setSerializer',
    value: function setSerializer() {
      var givenSerializer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    }

    /**
     * Get encryption key.
     *
     * @return {string}
     */

  }, {
    key: 'getEncryptionKey',
    value: function getEncryptionKey() {}

    /**
     * Set encryption key.
     *
     * @param {string}
     */

  }, {
    key: 'setEncryptionKey',
    value: function setEncryptionKey(value) {}

    /**
     * Get encryption method.
     *
     * @return {string}
     */

  }, {
    key: 'getEncryptionMethod',
    value: function getEncryptionMethod() {}

    /**
     * Set encryption method.
     *
     * @param {string}
     */

  }, {
    key: 'setEncryptionMethod',
    value: function setEncryptionMethod(value) {}

    /**
     * Determines if current adapter is supported.
     *
     * @protected
     * @returns {boolean}
     */

  }, {
    key: 'hasSupport',
    value: function hasSupport() {}

    /**
     * Determines if current adapter has support to events.
     *
     * @returns {boolean}
     */

  }, {
    key: 'hasEventsSupport',
    value: function hasEventsSupport() {}

    /**
     *
     * @param   {string}     key           The unique key of this item in the storage.
     * @returns {string}                   If keyPrefix's not empty then result will be both concatenated, else just the informed key.
     */

  }, {
    key: 'getUserKey',
    value: function getUserKey(key) {}

    /**
     *
     * @param   {string}     key           The unique key of this item in the storage.
     * @returns {string}                   If keyPrefix's not empty then result will be both concatenated, else just the informed key.
     */

  }, {
    key: 'getKernelJSKey',
    value: function getKernelJSKey(key) {}

    /**
     *
     * @param   {string} key
     * @returns {boolean}
     */

  }, {
    key: 'isKernelJSItem',
    value: function isKernelJSItem(key) {}

    /**
     * Get all items from storage.
     *
     * @returns {*}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'all',
    value: function all() {}

    /**
     * Determines whether an item is present in the storage.
     *
     * NOTE: It is recommended that has() is only to be used for storage warming type purposes
     * and not to be used within your live applications operations for getValue/set, as this method
     * is subject to a race condition where your has() will return true and immediately after,
     * another script can remove it making the state of your app out of date.
     *
     * @param   {string}     key           The storage item key.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'has',
    value: function has(key) {}

    /**
     * Fetches a value from the storage.
     *
     * @param   {string}     key           The unique key of this item in the storage.
     *                                     You can use dot notation on nested objects.
     * @param   {*}          defaultValue  Optional. Default value to return if the key does not exist or is null.
     *
     * @returns {*}                        The value of the item from the storage, or default in case of item miss.
     *
     * @throws  {DataError}
     */

  }, {
    key: 'get',
    value: function get(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Obtains multiple storage items by their unique keys.
     *
     * @param   {array}      keys          A list of keys that can obtained in a single operation.
     *                                     You can use dot notation on nested objects.
     * @param   {*}          defaultValue  Optional. Default value to return for keys that do not exist.
     *
     * @returns {object}                   An object with all key => value pairs.
     *                                     Keys that do not exist or is null will have defaultValue as value.
     *
     * @throws  {DataError}
     */

  }, {
    key: 'getMultiple',
    value: function getMultiple(keys) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Persists data in the storage, uniquely referenced by a key.
     *
     * @param   {string}     key           The key of the item to store.
     *                                     You can use dot notation on nested objects to change just a specific property.
     * @param   {*}          value         The value of the item to store, must be serializable.
     * @param   {object}     options       Optional configs. Not all adapters support it.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    }

    /**
     * Persists a set of key => value pairs in the storage.
     *
     * @param   {object}     values        An object with all key => value pairs for a multiple-set operation.
     *                                     You can use dot notation on nested objects to change just a specific property.
     * @param   {object}     options       Optional configs. Not all adapters support it.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'setMultiple',
    value: function setMultiple(values) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    }

    /**
     * Delete an item from the storage by its unique key.
     *
     * @param   {string}     key           The unique storage key of the item to delete.
     *                                     You can use dot notation on nested objects to delete just a specific property.
     * @param   {object}     options       Optional configs. Not all adapters support it.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'delete',
    value: function _delete(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    }

    /**
     * Deletes multiple storage items in a single operation.
     *
     * @param   {array}      values        A list of unique keys for a multiple-delete operation.
     *                                     You can use dot notation on nested objects to delete just a specific property.
     * @param   {object}     options       Optional configs. Not all adapters support it.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'deleteMultiple',
    value: function deleteMultiple(keys) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    }

    /**
     * Wipes clean the entire storage's keys.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'clear',
    value: function clear() {}

    /**
     * Returns entire storage's keys count.
     *
     * @returns {number}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'length',
    value: function length() {}

    /**
     * Get value at specific numeric index
     *
     * @param   {number}     index         The numeric index of the value on storage.
     * @param   {*}          defaultValue  Optional. Default value to return when index does not exist.
     *
     * @returns {*}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'index',
    value: function index(_index) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Returns if storage is empty.
     *
     * @returns {boolean}
     *
     * @throws  {DataError}
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {}

    /**
     * Listen for changes made by another instances.
     *
     * @param   {function}   closure       The function to be called when changes occurs by another instance.
     * @param   {array}      keys          Optional. If you want to specify only some keys to watch.
     *
     * @returns {*}
     */

  }, {
    key: 'listen',
    value: function listen(closure) {
      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    }
  }]);

  return AbstractAdapter;
}();

export default AbstractAdapter;